## 함수형 프로그래밍

- 작은 문제를 해결하기 위한 함수를 작성하는 방식

> 함수형 프로그래밍은 '대입문이 없는 프로그래밍'이다. - Clean Code 저자 Robert C.Martin

> 함수형 프로그래밍은 **무엇(What)**에 포커스를 둔다.

- '출력하는 함수'를 인자로 넘길 수 있음
  - 함수형 프로그래밍 기본원리 중 함수를 1급 시민, 1급 객체로 관리하는 특징 때문
  - 명령형 프로그래밍에선 메서드를 호출하면 상황에 따라 내부의 값이 바뀔 수 있음
    - = 함수 내에서 선언된 변수의 메모리에 할당된 값이 바뀌는 등의 상태변화가 발생
  - but 함수형 프로그래밍은 대입문이 없어 메모리에 한 번 할당된 값은 새로운 값으로 변할 수 없음
- 명령형 : ~한 과정을 거쳐 이걸 반환한다!
- 함수형 : ~이다!

> 부수 효과를 없애고, 함수 간 조합성을 강조하는 프로그래밍 패러다임

- 입출력이 순수 (순수함수)
  - 반드시 인자를 받고, 결과를 리턴해야함
  - **순수함수**
    - 인자를 제외한 다른 변수는 사용 X
    - 인자만으로 결과를 내야 함
    - JS this 때문에 순수함수를 사용하기 힘들지만, 비슷하게 할 수는 있음
- **side effect X**
  - 프로그래머가 바꾸고자하는 변수 외에는 바뀌어서는 안됨
  - 원본 데이터는 **불변**해야함
  - 함수형 프로그래밍에서는 프로그래머가 모든 것을 예측, 통제할 수 있어야함
- 함수 외부 데이터에 의존 X, 외부 데이터 변경 X
- 함수, 데이터를 중점으로 생각
  <br>
  <br>

## **함수형 프로그래밍 특징, 용어**

> 부수 효과가 없는 순수 함수를 1급 객체로 간주해 인자로 넘기거나 반환값으로 사용할 수 있으며, 참조 투명성을 지킬 수 있다.

**부수효과(Side Effect)**

- 변수값이 변경됨, 객체 필드값을 설정
- 예외나 오류 발생
- 콘솔, 파일 I/O 발생

**순수함수**(Pure Function)

- Side Effect가 없는 함수
- 함수 실행이 외부에 영향을 끼치지 않는 함수
  - 함수 자체가 독립적이고 Side-Effect가 없어 Thread 안전성을 보장
    - 병렬 처리를 동기화 없이 진행할 수 있음

**1급 객체**

> 함수형 프로그래밍의 함수는 1급 객체로 취급받기 때문에, 함수를 인자로 넘기는 등의 작업이 가능하다.

- 변수나 데이터 구조 안에 담을 수 있음
- 인자로 전달 가능
- 리턴값으로 사용 가능

**참조 투명성(Referential Transparency)**

> 함수를 실행해도 상태 변화 없이 항상 동일한 결과를 반환하여,
> 항상 동일한(= 투명한) 실행 결과를 참조(=예측)할 수 있다는 것

- 동일한 인자에 대해 → 항상 동일한 결과 반환
- 기존값은 변경되지 않고 유지됨 (Immutable)
  <br>
  <br>

## Javascript에서 활용하기

> 반복문 대신, 재귀함수 사용

- 대표적인 함수형 프로그래밍 함수 : **map**, **filter, reduce**

```jsx
// 예시1
var arr = [1, 2, 3, 4, 5];
var map = arr.map((x) => x * 2); // [2, 4, 6, 8, 10]
```

- 처음에 배열(arr)을 넣어서(입력), 결과(map)를 얻음(출력)
- arr도 사용은 됐지만, 값은 변하지 않았고, map이라는 결과를 내고 아무런 부작용도 낳지 않았습니다.

  ⇒ 바로 이런 게 **순수함수!**

```jsx
// 예시2
var arr = [1, 2, 3, 4, 5];
var condition = function (x) {
  return x % 2 === 0;
};
var ex = function (array) {
  return array.filter(condition);
};
ex(arr); // [2, 4]
```

- condition 변수 때문에 순수함수 X
- 인자로 받지 않은 변수 사용

```jsx
// 예시2 개선
var ex = function (array, cond) {
  return array.filter(cond);
};
ex(arr, condition);
```

- condition 변수 또한 인자로 받게 바꿔서 순수함수로 만듦
  - **쉽게 에러를 추적** 가능
    - 에러는 인자나, 함수 내부가 문제 둘 중 하나때문에 발생

### 반복문 처리

일반적인 경우

```jsx
var sum = 0;
for (var i = 1; i <= 10; i++) {
  sum += i;
}
```

함수형 프로그래밍1

- add 안에서 add를 또 호출
  - 코드의 **재사용성**이 매우 높아짐 (한 번 함수로 만들어놓으면 언제든 다시 쓸 수 있음)

```jsx
function add(sum, count) {
  sum += count;
  if (count > 0) return add(sum, count - 1);
  else return sum;
}
add(0, 10); // 55
```

함수형 프로그래밍2

- `reduce`

```jsx
var arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
arr.reduce((prev, cur) => prev + cur); // 55
```

### 외부 변수에 의존X

> 외부 데이터 변수인 a에 의존해서 순수함수 X

```jsx
let a = 0;
function increment1() {
  return (a += 1);
}
```

> 인자로 받은 a, 상수 1만 활용했기 때문에 순수함수 O

```jsx
increment2(a) {
	return a + 1;
}
```

### JS 콜렉션 인터페이스

> 함수형 프로그래밍 개념에 따라, **기존 변수에 대한 side effect가 없도록 구현**하는 것이 원칙

- `map`, `filter`, `reduce` 등의 고차함수 활용

**REFERENCE**

- [https://developer.mozilla.org/ko/](https://developer.mozilla.org/ko/)
- [https://velog.io/@goody/JS-함수형-프로그래밍](https://velog.io/@goody/JS-%ED%95%A8%EC%88%98%ED%98%95-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D)
